package method42

import (
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"fmt"

	ec "github.com/bsv-blockchain/go-sdk/primitives/ec"
)

const (
	// NonceLen is the length of the AES-GCM nonce in bytes.
	NonceLen = 12

	// GCMTagLen is the length of the GCM authentication tag in bytes.
	GCMTagLen = 16

	// MinCiphertextLen is the minimum valid ciphertext length (nonce + tag).
	MinCiphertextLen = NonceLen + GCMTagLen

	// MinEncPayloadLen is the minimum valid EncPayload length (salt + nonce + tag).
	MinEncPayloadLen = MetadataSaltLen + NonceLen + GCMTagLen
)

// EncryptResult holds the output of an encryption operation.
type EncryptResult struct {
	// Ciphertext is nonce(12B) || AES-256-GCM(plaintext, aes_key) || tag(16B).
	Ciphertext []byte

	// KeyHash is SHA256(SHA256(plaintext)), 32 bytes.
	// Serves as both KDF salt and content commitment.
	KeyHash []byte
}

// DecryptResult holds the output of a decryption operation.
type DecryptResult struct {
	// Plaintext is the decrypted content.
	Plaintext []byte

	// KeyHash is the recomputed SHA256(SHA256(plaintext)) for verification.
	KeyHash []byte
}

// Encrypt encrypts plaintext using Method 42.
//
// Process:
//  1. Computes key_hash = SHA256(SHA256(plaintext))
//  2. Performs ECDH(D_node, P_node) to get shared secret
//  3. Derives AES key via HKDF-SHA256
//  4. Encrypts with AES-256-GCM (random 12-byte nonce)
//
// For AccessFree: D_node is scalar 1 (anyone can reproduce).
// For AccessPrivate/AccessPaid: D_node is the BIP32-derived private key.
//
// # Nonce Safety Model
//
// AES-256-GCM uses a random 12-byte (96-bit) nonce generated by crypto/rand for
// each call to Encrypt. The birthday-bound probability of a nonce collision under
// the same AES key reaches a dangerous threshold (~2^-32 forgery probability)
// after approximately 2^48 encryptions. However, the conservative recommended
// limit from NIST SP 800-38D is 2^32 invocations per key.
//
// In Method 42, the AES key is derived deterministically as:
//
//	aes_key = HKDF-SHA256(ECDH(D_node, P_node).x, key_hash, "bitfs-file-encryption")
//
// The key is uniquely determined by the triple (D_node, P_node, key_hash), where
// key_hash = SHA256(SHA256(plaintext)). This means a distinct AES key is produced
// whenever ANY of these three inputs differs:
//
//   - Different parent node (different D_node from BIP32 derivation)
//   - Different node public key (different P_node)
//   - Different file content (different key_hash)
//
// Scenarios that are SAFE (produce a different AES key, resetting the nonce counter):
//
//   - File copy to a different directory: the destination has a different parent
//     Metanet node, yielding a different D_node and thus a different ECDH result.
//   - Re-encryption after content modification: the plaintext changes, so
//     key_hash = SHA256(SHA256(new_content)) differs, producing a new AES key.
//   - Access mode change between FREE and PRIVATE: effectivePrivateKey changes
//     (scalar 1 vs. actual D_node), so the ECDH shared secret differs.
//   - Different buyers in PAID mode: each buyer has a unique P_buyer, and the
//     capsule derivation uses a separate HKDF info string ("bitfs-buyer-mask").
//
// Scenarios requiring CARE (reuse the same AES key, incrementing the nonce counter):
//
//   - Repeated encrypt/decrypt cycles of the SAME file at the SAME path without
//     content changes. Each cycle calls Encrypt once with the same (D_node, P_node,
//     key_hash), consuming one random nonce under the same AES key. This is safe
//     in practice (a user would need to run encrypt+decrypt >4 billion times on
//     the same unchanged file to approach the 2^32 conservative bound), but the
//     invariant should be documented.
//   - ReEncrypt with identical from/to access modes on unchanged content: this
//     decrypts and re-encrypts, consuming one nonce under the same key. Same
//     practical safety margin as above.
//
// Safety invariant: a given (D_node, P_node, key_hash) triple MUST NOT be used
// for more than 2^32 Encrypt invocations. In normal BitFS usage (files are
// written once and read many times), this bound is never approached.
func Encrypt(plaintext []byte, privateKey *ec.PrivateKey, publicKey *ec.PublicKey, access Access) (*EncryptResult, error) {
	if publicKey == nil {
		return nil, ErrNilPublicKey
	}

	// Step 1: Compute key_hash = SHA256(SHA256(plaintext))
	keyHash := ComputeKeyHash(plaintext)

	// Step 2: Get effective private key based on access mode
	effKey, err := effectivePrivateKey(access, privateKey)
	if err != nil {
		return nil, err
	}

	// Step 3: ECDH to get shared secret x-coordinate
	sharedX, err := ECDH(effKey, publicKey)
	if err != nil {
		return nil, fmt.Errorf("method42: ECDH failed: %w", err)
	}

	// Step 4: Derive AES key via HKDF-SHA256
	aesKey, err := DeriveAESKey(sharedX, keyHash)
	if err != nil {
		return nil, err
	}

	// Step 5: Encrypt with AES-256-GCM
	ciphertext, err := aesGCMEncrypt(plaintext, aesKey)
	if err != nil {
		return nil, err
	}

	return &EncryptResult{
		Ciphertext: ciphertext,
		KeyHash:    keyHash,
	}, nil
}

// Decrypt decrypts ciphertext using Method 42.
//
// Process:
//  1. Performs ECDH to recover shared secret
//  2. Derives AES key using provided key_hash
//  3. Decrypts with AES-256-GCM
//  4. Verifies SHA256(SHA256(plaintext)) == key_hash
func Decrypt(ciphertext []byte, privateKey *ec.PrivateKey, publicKey *ec.PublicKey, keyHash []byte, access Access) (*DecryptResult, error) {
	if publicKey == nil {
		return nil, ErrNilPublicKey
	}
	if len(keyHash) != 32 {
		return nil, fmt.Errorf("%w: key hash must be 32 bytes", ErrKeyHashMismatch)
	}

	// Get effective private key based on access mode
	effKey, err := effectivePrivateKey(access, privateKey)
	if err != nil {
		return nil, err
	}

	// ECDH to get shared secret x-coordinate
	sharedX, err := ECDH(effKey, publicKey)
	if err != nil {
		return nil, fmt.Errorf("method42: ECDH failed: %w", err)
	}

	// Derive AES key via HKDF-SHA256
	aesKey, err := DeriveAESKey(sharedX, keyHash)
	if err != nil {
		return nil, err
	}

	// Decrypt with AES-256-GCM
	plaintext, err := aesGCMDecrypt(ciphertext, aesKey)
	if err != nil {
		return nil, err
	}

	// Verify content integrity: SHA256(SHA256(plaintext)) == keyHash
	computedHash := ComputeKeyHash(plaintext)
	if !bytes.Equal(computedHash, keyHash) {
		return nil, ErrKeyHashMismatch
	}

	return &DecryptResult{
		Plaintext: plaintext,
		KeyHash:   computedHash,
	}, nil
}

// DecryptWithCapsule decrypts using an XOR-masked capsule obtained via HTLC
// (legacy deterministic version without nonce).
//
// The buyer recovers the AES key as:
//
//	buyer_mask = HKDF(ECDH(D_buyer, P_node).x, key_hash, "bitfs-buyer-mask")
//	aes_key    = capsule XOR buyer_mask
//
// This works because the seller computed:
//
//	capsule = aes_key XOR HKDF(ECDH(D_node, P_buyer).x, key_hash, "bitfs-buyer-mask")
//
// and ECDH(D_buyer, P_node) == ECDH(D_node, P_buyer) by ECDH symmetry.
//
// For capsules generated with ComputeCapsuleWithNonce, use DecryptWithCapsuleNonce
// instead, passing the same nonce used during capsule generation.
func DecryptWithCapsule(ciphertext []byte, capsule []byte, keyHash []byte,
	buyerPrivateKey *ec.PrivateKey, nodePublicKey *ec.PublicKey) (*DecryptResult, error) {
	return DecryptWithCapsuleNonce(ciphertext, capsule, keyHash, buyerPrivateKey, nodePublicKey, nil)
}

// DecryptWithCapsuleNonce decrypts using an XOR-masked capsule obtained via HTLC,
// with an optional per-invoice nonce for capsule unlinkability.
//
// The buyer recovers the AES key as:
//
//	buyer_mask = HKDF(ECDH(D_buyer, P_node).x, key_hash || nonce, "bitfs-buyer-mask")
//	aes_key    = capsule XOR buyer_mask
//
// The nonce must match the one used by the seller in ComputeCapsuleWithNonce.
// When nonce is nil, this is equivalent to DecryptWithCapsule (legacy behavior).
func DecryptWithCapsuleNonce(ciphertext []byte, capsule []byte, keyHash []byte,
	buyerPrivateKey *ec.PrivateKey, nodePublicKey *ec.PublicKey, nonce []byte) (*DecryptResult, error) {
	if buyerPrivateKey == nil {
		return nil, ErrNilPrivateKey
	}
	if nodePublicKey == nil {
		return nil, ErrNilPublicKey
	}
	if len(capsule) == 0 {
		return nil, fmt.Errorf("method42: capsule is empty")
	}
	if len(keyHash) != 32 {
		return nil, fmt.Errorf("%w: key hash must be 32 bytes", ErrKeyHashMismatch)
	}

	// 1. sharedBuyer = ECDH(D_buyer, P_node)
	sharedBuyer, err := ECDH(buyerPrivateKey, nodePublicKey)
	if err != nil {
		return nil, fmt.Errorf("method42: capsule ECDH failed: %w", err)
	}

	// 2. buyerMask = DeriveBuyerMaskWithNonce(sharedBuyer, keyHash, nonce)
	buyerMask, err := DeriveBuyerMaskWithNonce(sharedBuyer, keyHash, nonce)
	if err != nil {
		return nil, err
	}

	// 3. aesKey = capsule XOR buyerMask
	aesKey := xorBytes(capsule, buyerMask)

	// 4. Decrypt with AES-256-GCM
	plaintext, err := aesGCMDecrypt(ciphertext, aesKey)
	if err != nil {
		return nil, err
	}

	// 5. Verify content integrity: SHA256(SHA256(plaintext)) == keyHash
	computedHash := ComputeKeyHash(plaintext)
	if !bytes.Equal(computedHash, keyHash) {
		return nil, ErrKeyHashMismatch
	}

	return &DecryptResult{
		Plaintext: plaintext,
		KeyHash:   computedHash,
	}, nil
}

// ReEncrypt re-encrypts content from one access mode to another.
// Decrypts with fromAccess parameters, then encrypts with toAccess parameters.
// Returns new ciphertext and new key_hash.
//
// Supported conversions:
//   - FREE -> PRIVATE (encrypt command)
//   - PRIVATE -> FREE (decrypt command)
func ReEncrypt(ciphertext []byte, privateKey *ec.PrivateKey, publicKey *ec.PublicKey, keyHash []byte, fromAccess, toAccess Access) (*EncryptResult, error) {
	// Decrypt with old access mode
	result, err := Decrypt(ciphertext, privateKey, publicKey, keyHash, fromAccess)
	if err != nil {
		return nil, fmt.Errorf("method42: re-encrypt decrypt failed: %w", err)
	}

	// Encrypt with new access mode
	return Encrypt(result.Plaintext, privateKey, publicKey, toAccess)
}

// EncryptMetadata encrypts a TLV metadata payload for PRIVATE mode.
//
// Uses a random 16-byte salt for HKDF key derivation (P0 ยง3.2 fix).
// Output format: salt(16B) || nonce(12B) || AES-GCM(tlvPayload) || tag(16B).
//
// The caller stores the returned bytes as the node's EncPayload field.
func EncryptMetadata(tlvPayload []byte, privateKey *ec.PrivateKey, publicKey *ec.PublicKey) ([]byte, error) {
	if privateKey == nil {
		return nil, ErrNilPrivateKey
	}
	if publicKey == nil {
		return nil, ErrNilPublicKey
	}

	sharedX, err := ECDH(privateKey, publicKey)
	if err != nil {
		return nil, fmt.Errorf("method42: metadata ECDH failed: %w", err)
	}

	metaKey, salt, err := DeriveMetadataKey(sharedX)
	if err != nil {
		return nil, err
	}

	ciphertext, err := aesGCMEncrypt(tlvPayload, metaKey)
	if err != nil {
		return nil, err
	}

	// EncPayload = salt(16B) || nonce(12B) || ciphertext || tag(16B)
	encPayload := make([]byte, MetadataSaltLen+len(ciphertext))
	copy(encPayload, salt)
	copy(encPayload[MetadataSaltLen:], ciphertext)
	return encPayload, nil
}

// DecryptMetadata decrypts a PRIVATE mode EncPayload back to TLV bytes.
//
// Input format: salt(16B) || nonce(12B) || AES-GCM(tlvPayload) || tag(16B).
func DecryptMetadata(encPayload []byte, privateKey *ec.PrivateKey, publicKey *ec.PublicKey) ([]byte, error) {
	if privateKey == nil {
		return nil, ErrNilPrivateKey
	}
	if publicKey == nil {
		return nil, ErrNilPublicKey
	}
	if len(encPayload) < MinEncPayloadLen {
		return nil, fmt.Errorf("%w: EncPayload too short (%d bytes, min %d)", ErrInvalidCiphertext, len(encPayload), MinEncPayloadLen)
	}

	salt := encPayload[:MetadataSaltLen]
	ciphertext := encPayload[MetadataSaltLen:]

	sharedX, err := ECDH(privateKey, publicKey)
	if err != nil {
		return nil, fmt.Errorf("method42: metadata ECDH failed: %w", err)
	}

	metaKey, err := DeriveMetadataKeyWithSalt(sharedX, salt)
	if err != nil {
		return nil, err
	}

	return aesGCMDecrypt(ciphertext, metaKey)
}

// aesGCMEncrypt encrypts plaintext with AES-256-GCM.
// Returns nonce(12B) || ciphertext || tag(16B).
func aesGCMEncrypt(plaintext, key []byte) ([]byte, error) {
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, fmt.Errorf("%w: AES cipher creation failed: %w", ErrDecryptionFailed, err)
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, fmt.Errorf("%w: GCM creation failed: %w", ErrDecryptionFailed, err)
	}

	// Generate random nonce
	nonce := make([]byte, gcm.NonceSize())
	if _, err := rand.Read(nonce); err != nil {
		return nil, fmt.Errorf("method42: random nonce generation failed: %w", err)
	}

	// Output format: nonce(12B) || ciphertext || GCM tag(16B)
	ciphertext := gcm.Seal(nonce, nonce, plaintext, nil)
	return ciphertext, nil
}

// aesGCMDecrypt decrypts AES-256-GCM ciphertext.
// Input format: nonce(12B) || ciphertext || tag(16B).
func aesGCMDecrypt(ciphertext, key []byte) ([]byte, error) {
	if len(ciphertext) < MinCiphertextLen {
		return nil, ErrInvalidCiphertext
	}

	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, fmt.Errorf("%w: AES cipher creation failed: %w", ErrDecryptionFailed, err)
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, fmt.Errorf("%w: GCM creation failed: %w", ErrDecryptionFailed, err)
	}

	nonceSize := gcm.NonceSize()
	if len(ciphertext) < nonceSize {
		return nil, ErrInvalidCiphertext
	}

	nonce := ciphertext[:nonceSize]
	encrypted := ciphertext[nonceSize:]

	plaintext, err := gcm.Open(nil, nonce, encrypted, nil)
	if err != nil {
		return nil, ErrDecryptionFailed
	}

	// Normalize nil to empty slice for consistency.
	if plaintext == nil {
		plaintext = []byte{}
	}

	return plaintext, nil
}
